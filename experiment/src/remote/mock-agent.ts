/**
 * Mock Agent for AWCP Experiment
 * 
 * A simple agent that performs file operations without requiring an LLM.
 * Supports different operation modes for various testing scenarios.
 */

import { readdir, readFile, writeFile, stat } from 'fs/promises';
import { join, relative, extname } from 'path';

export interface MockAgentConfig {
  /** Agent operation type */
  type: 'add-header' | 'create-summary' | 'uppercase-comments';
}

export interface TaskParams {
  /** Mounted workspace path */
  mountPoint: string;
  /** Task description */
  task: {
    description: string;
    prompt: string;
  };
  /** Delegation ID */
  delegationId: string;
}

export interface TaskResult {
  /** Summary of what was done */
  summary: string;
  /** List of modified/created files */
  highlights?: string[];
  /** Additional notes */
  notes?: string;
}

export class MockAgent {
  private config: MockAgentConfig;

  constructor(config: MockAgentConfig) {
    this.config = config;
  }

  /**
   * Execute the task on the mounted workspace
   */
  async execute(params: TaskParams): Promise<TaskResult> {
    console.log(`[Mock Agent] Starting task execution...`);
    console.log(`[Mock Agent] Type: ${this.config.type}`);
    console.log(`[Mock Agent] Mount point: ${params.mountPoint}`);
    console.log(`[Mock Agent] Task: ${params.task.description}`);

    switch (this.config.type) {
      case 'add-header':
        return this.addHeaderToFiles(params);
      case 'create-summary':
        return this.createSummary(params);
      case 'uppercase-comments':
        return this.uppercaseComments(params);
      default:
        return this.addHeaderToFiles(params);
    }
  }

  /**
   * Add header comments to all TypeScript files
   */
  private async addHeaderToFiles(params: TaskParams): Promise<TaskResult> {
    const { mountPoint, delegationId } = params;
    const modifiedFiles: string[] = [];
    const timestamp = new Date().toISOString();

    const header = `/**
 * Modified by AWCP Mock Agent
 * Delegation ID: ${delegationId.slice(0, 8)}...
 * Timestamp: ${timestamp}
 * Task: ${params.task.description}
 */

`;

    // Find all TypeScript files
    const tsFiles = await this.findFiles(mountPoint, ['.ts', '.tsx', '.js', '.jsx']);
    
    console.log(`[Mock Agent] Found ${tsFiles.length} source files`);

    for (const file of tsFiles) {
      try {
        const content = await readFile(file, 'utf-8');
        
        // Skip if already has our header
        if (content.includes('Modified by AWCP Mock Agent')) {
          console.log(`[Mock Agent] Skipping (already modified): ${relative(mountPoint, file)}`);
          continue;
        }

        const newContent = header + content;
        await writeFile(file, newContent, 'utf-8');
        
        const relativePath = relative(mountPoint, file);
        modifiedFiles.push(relativePath);
        console.log(`[Mock Agent] ✓ Modified: ${relativePath}`);
      } catch (error) {
        console.error(`[Mock Agent] ✗ Error processing ${file}:`, error);
      }
    }

    // Create result file
    const resultContent = `# AWCP Agent Execution Result

## Delegation Info
- **ID**: ${delegationId}
- **Timestamp**: ${timestamp}
- **Task**: ${params.task.description}

## Modified Files
${modifiedFiles.map(f => `- \`${f}\``).join('\n')}

## Summary
Added header comments to ${modifiedFiles.length} source files.
`;

    await writeFile(join(mountPoint, 'AWCP_RESULT.md'), resultContent, 'utf-8');
    modifiedFiles.push('AWCP_RESULT.md');

    return {
      summary: `Added header comments to ${modifiedFiles.length - 1} source files`,
      highlights: modifiedFiles,
      notes: `Execution completed at ${timestamp}`,
    };
  }

  /**
   * Create a summary of the workspace
   */
  private async createSummary(params: TaskParams): Promise<TaskResult> {
    const { mountPoint, delegationId } = params;
    const timestamp = new Date().toISOString();
    
    // Count files by extension
    const allFiles = await this.findFiles(mountPoint, []);
    const extCounts: Record<string, number> = {};
    
    for (const file of allFiles) {
      const ext = extname(file) || '(no extension)';
      extCounts[ext] = (extCounts[ext] || 0) + 1;
    }

    // Create summary
    const summaryContent = `# Workspace Summary

## Generated by AWCP Mock Agent
- **Delegation ID**: ${delegationId}
- **Timestamp**: ${timestamp}

## File Statistics
- **Total Files**: ${allFiles.length}

### By Extension
${Object.entries(extCounts)
  .sort((a, b) => b[1] - a[1])
  .map(([ext, count]) => `- ${ext}: ${count}`)
  .join('\n')}

## Task
${params.task.description}

---
*This summary was automatically generated by AWCP Mock Agent*
`;

    await writeFile(join(mountPoint, 'WORKSPACE_SUMMARY.md'), summaryContent, 'utf-8');

    return {
      summary: `Created workspace summary with ${allFiles.length} files analyzed`,
      highlights: ['WORKSPACE_SUMMARY.md'],
      notes: `Found ${Object.keys(extCounts).length} different file types`,
    };
  }

  /**
   * Convert comments to uppercase (demo operation)
   */
  private async uppercaseComments(params: TaskParams): Promise<TaskResult> {
    const { mountPoint } = params;
    const modifiedFiles: string[] = [];

    const tsFiles = await this.findFiles(mountPoint, ['.ts', '.tsx']);

    for (const file of tsFiles) {
      const content = await readFile(file, 'utf-8');
      
      // Simple regex to find single-line comments and uppercase them
      const newContent = content.replace(
        /\/\/\s*(.+)/g,
        (_, comment) => `// ${comment.toUpperCase()}`
      );

      if (newContent !== content) {
        await writeFile(file, newContent, 'utf-8');
        modifiedFiles.push(relative(mountPoint, file));
      }
    }

    return {
      summary: `Uppercased comments in ${modifiedFiles.length} files`,
      highlights: modifiedFiles,
    };
  }

  /**
   * Recursively find files with given extensions
   */
  private async findFiles(dir: string, extensions: string[]): Promise<string[]> {
    const results: string[] = [];

    try {
      const entries = await readdir(dir, { withFileTypes: true });

      for (const entry of entries) {
        const fullPath = join(dir, entry.name);

        // Skip hidden files and common ignored directories
        if (entry.name.startsWith('.') || 
            entry.name === 'node_modules' || 
            entry.name === 'dist' ||
            entry.name === 'build') {
          continue;
        }

        if (entry.isDirectory()) {
          const subFiles = await this.findFiles(fullPath, extensions);
          results.push(...subFiles);
        } else if (entry.isFile()) {
          if (extensions.length === 0 || extensions.some(ext => entry.name.endsWith(ext))) {
            results.push(fullPath);
          }
        }
      }
    } catch (error) {
      console.error(`[Mock Agent] Error reading directory ${dir}:`, error);
    }

    return results;
  }
}
